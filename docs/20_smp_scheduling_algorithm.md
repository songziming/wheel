# 多核任务调度策略

一个好的调度策略需要满足以下目标：

- CPU 利用率高
- 抢占式调度，避免阻塞，先来的任务不能独占CPU导致后面的任务得不到运行
- 按优先级调度
- 较少迁移，算法尽量在一个CPU之内完成
- 负载均衡

这几个任务有一些冲突，如果根据优先级调度，则必然需要寻找当前优先级最低的 CPU，抢占其上的任务

是否可以禁用抢占，创建任务时就指定目标 CPU 编号？
至于负载均衡，完全可以让用户进程自己负责。创建线程池，N 个 worker 运行在各自 CPU 上。
可以在 OS 级别提供线程池的支持，运行哪个进程的 work 就切换到哪个地址空间。

传统进程模型：进程作为负载，切分成若干时间片，将时间片分配给不同 CPU（push）
申请式进程模型：进程是计算任务，每个CPU都可以申请计算任务，申请成功就开始执行

当每个 CPU 开始运行 idle 任务，说明这个 CPU 没有负载，可以去申请新的计算任务了
计算任务需要来自全局数据结构，这个数据结构最好是无锁的。

### 调度器视角下，任务的生命周期

对调度器而言，只有 ready 状态的任务才有意义。
任务变为 ready 放入队列，任务不再 ready 移除队列，相当于任务的生命周期结束了。

不能依靠任务自己退出 ready，时间可能很长，必须让时钟中断主动打断执行。

### Linux CFS 设计思路

CFS 的想法是很好的，假设存在一个理想的多线程匀速处理器，可以按相同的速度执行所有 ready 线程。

但实际的 CPU 显然不理想，我们只能把所有的 ready 负载分给几个 CPU。

如果所有的应用程序也是我们自己开发，而且 CPU 已知，完全可以手动指定亲和性。但如果配置不好，容易出现“一核有难，N-1核围观”的情况。

把任务集粗略划分给各个 CPU，每个 CPU 在内部 round robin。但这样可能出现负载失衡，需要定期执行 rebalance。

### 使用统一的全局就绪队列

更理想的情况是，所有 cpu 共享同一个 ready_queue，每个 cpu 需要调度任务时都从这个队列取任务。

这个数据结构最好是 lockless，让使用者不需要频繁加锁等待。

但是 lockless 没有银弹，只能用 compare-and-update 循环与 atomic 操作实现。

每一种 lockless 数据结构都要专门设计。

### 如何使用锁

为了提高性能，应尽量避免数据共享，
