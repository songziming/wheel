# 任务

task 是最基本的调度单位。可以创建、暂停、恢复、删除。

## 任务在执行时用到的资源

仅考虑内核任务。

代码段、数据段来自 kernel image，必然存在。

函数栈，其物理页和虚拟地址范围都是动态分配的，记录在 task_t 里面。发生异常时，也用这个任务栈。这是最核心的资源。

还有一些全局资源，如中断栈、异常 IST。这些资源会被任务用到，但不独属于哪个任务。

## 改变任务执行状态

这里就涉及到了就绪队列（ready_q），可以运行的任务都放在 ready_q。

任务不再就绪，就要从 ready_q 中取出。任务和 ready_q 都有自旋锁，必须持有任务的自旋锁，就可以修改任务状态。持有 ready_q 的自旋锁，就可以将任务从 ready_q 中取出。

## 删除当前任务

删除任务，需要释放任务栈。任务还在运行时，显然无法释放栈。

正在运行的任务删除自己，就是删除正在运行的任务。需要首先把当前任务停止，然后在任务之外删除自己。

一个合理的选择是下一次中断。正在运行的任务停止了，显然要切换到新的任务，必然要执行 task_switch，即模拟一次中断。

我们将删除任务的函数注册到 work_q，在中断返回阶段清空 work_q。

## 删除另一个 CPU 上正在运行的任务

修改目标任务的状态，从 ready_q 中移除。此时目标任务还在运行，必须等目标 CPU 发生下一次中断，目标任务才会被换出。

删除 TCB，要等目标 CPU 发生 task_switch 之后。在当前 CPU 上忙等待显然不合适。只有目标CPU才知道何时发生task_switch，因此应该把 task_delete 函数注册到目标 CPU 的 work_q 队列中。

或者，改变目标任务执行状态，将任务从就绪队列中取出的操作，也可以交给目标 CPU 执行。直接向目标 CPU 发送 IPI，在中断处理程序中停止任务。

---

# 并发情况分析

任何 CPU 都可能操作 ready_q，任何任务都可能操作任何其他任务。信号量可能动态创建，也可能动态删除。

阻塞状态的任务也可能被删除，此时需要找出任务阻塞在哪个信号量，将任务从那个信号量的阻塞队列中移除。

此过程涉及很多自旋锁，任务的锁、就绪队列的锁、阻塞队列的锁、信号量的锁。不同操作获取锁的顺序不一致，可能导致死锁。

如何防止删除信号量时访问野指针？需要访问同一个信号量的任务显然要相互配合，也应该知道合适可以删除 semaphre，何时不能。
只有所有 worker 任务已经结束，才能保证 semaphre 以不再使用，这时才可以将信号量删除。

如果不加检查，直接删除一个正在使用的信号量，其他任务尝试获取不存在的信号量，就会产生 #PF。能否在尝试删除信号量时检查一下，有没有任务正在使用这个信号量？
只能检查有没有阻塞的，无法判断有没有正在使用的。只能把 semaphore 包含在更上层的结构中，由上层结构判断。

### 减少可能的 case 数量？

任务调度方面，各种锁的使用情况很复杂，因为要分类讨论的情况非常多。

例如删除一个任务：
- 自己删除自己
- 删除当前 CPU 上正在运行（就绪）的任务
- 删除其他 CPU 上正在运行的任务
- 删除阻塞的任务，还要找到阻塞在哪个队列中

case 太多，代码就会复杂。为了简化情况，可以规定只有任务自己可以删除自己。这样各种 case 都变成了发送消息，汇总成一种情况。
限制某种操作只能由特定任务执行，这种思路有点类似微内核。关键是如何收发消息，目标任务还不是消息循环。最可靠的方法就是中断。
先判断目标任务在哪个 CPU 运行，给目标 CPU 发送 IPI，目标 CPU 在 IPI 里面执行操作。如果在当前 CPU 运行，也可以发送 SELF-IPI。
这样，相当于所有的调用都是在 int handler 里面执行？如果耗时较长，可以分成 top-half 与 bottom-half。bottom-half 在专门的 tJobTask 任务里运行。

## 极端的微内核设计

Android 在上层也在模拟微内核设计，Minix 则是彻底的微内核。这样的内核就连进程创建删除也是通过 IPC 实现的。
