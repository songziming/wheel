# 任务

task 是最基本的调度单位。可以创建、暂停、恢复、删除。

## 为任务分配的资源

- 代码段、数据段（如果是内核任务，这两个段来自 kernel image）。
- 运行栈，物理页、vmrange 是动态分配的，更新内核页表
- 任务描述块（TCB），还有里面的任务名称字段，都是从内核堆分配的

## 任务的状态

- 就绪态，可以运行，放在就绪队列中
- 非就绪，因为某种原因不能运行，原因可能有（可以组合）：
  - 阻塞，正在等待信号量、消息队列等资源
  - 暂停，没有等待任何资源，被其他任务修改，例如正在被调试、任务刚创建

停止一个任务，只能由这个任务自己执行。恢复一个任务，只能由其他任务或中断执行。

## 任务状态的改变

提供若干任务状态配置函数，给任务状态添加停止位、去掉停止位。
状态改变后，也要修改所处的队列。就绪变为非就绪，要从 ready_q 取出任务；非就绪变为就绪，要将任务放入 ready_q。
如果涉及到阻塞态，还要把阻塞的任务放入阻塞队列。

task_pend、task_resume、task_stop、task_continue 这些函数显然是由其他任务调用的，caller 必须确保目标任务存在。
操作过程中，目标任务的 TCB、就绪队列、信号量，这些对象都有自旋锁，需要按相同顺序获取。
而且，可能在一个 CPU 上修改另一个 CPU 的就绪队列，还要考虑到多核导致的竞争。

* * *

## 改变任务执行状态

这里就涉及到了就绪队列（ready_q），可以运行的任务都放在 ready_q。

任务不再就绪，就要从 ready_q 中取出。任务和 ready_q 都有自旋锁，必须持有任务的自旋锁，就可以修改任务状态。持有 ready_q 的自旋锁，就可以将任务从 ready_q 中取出。

## 删除当前任务

删除任务，需要释放任务栈。任务还在运行时，显然无法释放栈。

正在运行的任务删除自己，就是删除正在运行的任务。需要首先把当前任务停止，然后在任务之外删除自己。

一个合理的选择是下一次中断。正在运行的任务停止了，显然要切换到新的任务，必然要执行 task_switch，即模拟一次中断。

我们将删除任务的函数注册到 work_q，在中断返回阶段清空 work_q。

## 删除另一个 CPU 上正在运行的任务

修改目标任务的状态，从 ready_q 中移除。此时目标任务还在运行，必须等目标 CPU 发生下一次中断，目标任务才会被换出。

删除 TCB，要等目标 CPU 发生 task_switch 之后。在当前 CPU 上忙等待显然不合适。只有目标CPU才知道何时发生task_switch，因此应该把 task_delete 函数注册到目标 CPU 的 work_q 队列中。

或者，改变目标任务执行状态，将任务从就绪队列中取出的操作，也可以交给目标 CPU 执行。直接向目标 CPU 发送 IPI，在中断处理程序中停止任务。

---

# 并发情况分析

任何 CPU 都可能操作 ready_q，任何任务都可能操作任何其他任务。信号量可能动态创建，也可能动态删除。

阻塞状态的任务也可能被删除，此时需要找出任务阻塞在哪个信号量，将任务从那个信号量的阻塞队列中移除。

此过程涉及很多自旋锁，任务的锁、就绪队列的锁、阻塞队列的锁、信号量的锁。不同操作获取锁的顺序不一致，可能导致死锁。

如何防止删除信号量时访问野指针？需要访问同一个信号量的任务显然要相互配合，也应该知道合适可以删除 semaphre，何时不能。
只有所有 worker 任务已经结束，才能保证 semaphre 以不再使用，这时才可以将信号量删除。

如果不加检查，直接删除一个正在使用的信号量，其他任务尝试获取不存在的信号量，就会产生 #PF。能否在尝试删除信号量时检查一下，有没有任务正在使用这个信号量？
只能检查有没有阻塞的，无法判断有没有正在使用的。只能把 semaphore 包含在更上层的结构中，由上层结构判断。

### 减少可能的 case 数量？

任务调度方面，各种锁的使用情况很复杂，因为要分类讨论的情况非常多。

例如删除一个任务：
- 自己删除自己
- 删除当前 CPU 上正在运行（就绪）的任务
- 删除其他 CPU 上正在运行的任务
- 删除阻塞的任务，还要找到阻塞在哪个队列中

case 太多，代码就会复杂。为了简化情况，可以规定只有任务自己可以删除自己。这样各种 case 都变成了发送消息，汇总成一种情况。
限制某种操作只能由特定任务执行，这种思路有点类似微内核。关键是如何收发消息，目标任务还不是消息循环。最可靠的方法就是中断。
先判断目标任务在哪个 CPU 运行，给目标 CPU 发送 IPI，目标 CPU 在 IPI 里面执行操作。如果在当前 CPU 运行，也可以发送 SELF-IPI。
这样，相当于所有的调用都是在 int handler 里面执行？如果耗时较长，可以分成 top-half 与 bottom-half。bottom-half 在专门的 tJobTask 任务里运行。

## 极端的微内核设计

Android 在上层也在模拟微内核设计，Minix 则是彻底的微内核。这样的内核就连进程创建删除也是通过 IPC 实现的。
