# 任务

task 是最基本的调度单位。可以创建、暂停、恢复、删除。

## 任务在执行时用到的资源

仅考虑内核任务。

代码段、数据段来自 kernel image，必然存在。

函数栈，其物理页和虚拟地址范围都是动态分配的，记录在 task_t 里面。发生异常时，也用这个任务栈。这是最核心的资源。

还有一些全局资源，如中断栈、异常 IST。这些资源会被任务用到，但不独属于哪个任务。

## 改变任务执行状态

这里就涉及到了就绪队列（ready_q），可以运行的任务都放在 ready_q。

任务不再就绪，就要从 ready_q 中取出。任务和 ready_q 都有自旋锁，必须持有任务的自旋锁，就可以修改任务状态。持有 ready_q 的自旋锁，就可以将任务从 ready_q 中取出。

## 删除当前任务

删除任务，需要释放任务栈。任务还在运行时，显然无法释放栈。

正在运行的任务删除自己，就是删除正在运行的任务。需要首先把当前任务停止，然后在任务之外删除自己。

一个合理的选择是下一次中断。正在运行的任务停止了，显然要切换到新的任务，必然要执行 task_switch，即模拟一次中断。

我们将删除任务的函数注册到 work_q，在中断返回阶段清空 work_q。

## 删除另一个 CPU 上正在运行的任务

修改目标任务的状态，从 ready_q 中移除。此时目标任务还在运行，必须等目标 CPU 发生下一次中断，目标任务才会被换出。

删除 TCB，要等目标 CPU 发生 task_switch 之后。在当前 CPU 上忙等待显然不合适。只有目标CPU才知道何时发生task_switch，因此应该把 task_delete 函数注册到目标 CPU 的 work_q 队列中。
