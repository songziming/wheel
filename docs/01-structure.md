# 内核的代码组织结构

如何划分功能模块？
模块之间平级还是嵌套？
是否存在基础模块？

### 硬件抽象层、通用硬件抽象接口

目前 wheel 只支持 x86 一种硬件，但保留未来扩展的能力。代码分成硬件相关和硬件无关的两部分，二者相互调用。

与特定硬件相关部分也叫硬件抽象层（HAL），是单独一个模块，包括以下内容：
- 编译链接命令行参数（`option.mk`）
- 内核 section 布局（`layout.ld`）
- 代码中用到的配置、宏定义（`arch_config.h`）
- 启动代码、平台特有硬件的驱动、平台相关的支持函数（`arch_api.h`）

硬件相关部分对外接口应该统一，`arch_api.h` 应该放在 core 而不是 arch 模块中。
但是，硬件抽象层对外提供的不仅有函数，还有宏定义、内联函数、中断上下文等，这部分只能由 arch 模块自己提供。

##### arch_api.h 由谁实现

`arch_api.h` 定义了每个平台需要实现的通用接口，但没有实现，实现是 hal 提供的。
那么在 hal 内部，具体由哪个文件提供实现？可以把全部的实现放在 arch_api.c，也可以按照功能拆分到不同文件中。

### 如何单元测试

在 host 环境下运行内核代码的单元测试，难点包括：
- 部分内核模块需要专门的环境（中断、需要特定内存布局）
- 符号冲突，特别是 libc 相关函数

由单元测试文件主动引用被测文件，可以选择哪些代码需要测试。
尽量避免使用相同的符号名，给内核函数加上前缀或后缀 `k`。

某些函数标记为弱符号，arch 模块提供了优化的实现方式，这些代码要如何测试？
要测试 x86_64 硬件平台的优化版 string 函数，只能在相同架构的 host 环境运行。

### 运行时测试

除了单元测试，正常运行也可以加入一些检查逻辑，例如assert。
如果内核运行在调试模式下，遇到assert失败，就打印调试信息。

QEMU 和 Bochs 可以通过特殊寄存器强行停止，还可以设置模拟器的返回值。这个机制可以用于模拟器测试。

### 测试不同的编译config？

有些选项编译前配置好，会决定编译得到的系统，影响运行效果。
尝试每一种配置组合，每种组合都编译一个版本，在模拟器上运行，执行相关 runtime 测试代码，如果一切正常，则返回代码 0。

---

# 如何处理内核高耦合度的问题

高耦合的体现：同一段代码，可能涉及到内存管理、多核、进程管理，不管放在什么位置都不合适。
