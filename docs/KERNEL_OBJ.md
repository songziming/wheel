# 内核对象与句柄

- 内核对象：kobj
- 句柄：handle

凡是动态分配的内核空间的 object，就是内核对象。task_t、blk_dev_t、semaphore_t，这些都是内核对象。

内核对象可能被随时创建，随时删除。一个任务持有某个 kobj 的指针，可能该对象就被其他任务删除了，该任务全然不知。

指针变成野指针，显然要通过流程设计避免这种情况。但也可以通过 handle 解决。

指针是单向的，任务 T1 持有对象 A1 的指针，但 A1 不知道自己正在被 T1 引用。如果此时 A1 删除了，无法告知 T1。

句柄是双向的，有点类似于链表节点。任务 T1 持有 A1 的句柄，A1 也知道引用自己的句柄有哪些。

如果要删除对象 A1，可以遍历引用自己的句柄（遍历链表），将每个句柄标记为失效（invalid）。


有点类似 C++ 自动指针？智能指针？
